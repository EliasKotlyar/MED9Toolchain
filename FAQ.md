## How does this application work?

```text
  See patcher/patches/mapswitch folder for a sample implementation
```


The Application works in 3 Steps:

### Step 1: Analysis
First the analyser function will analyse your input binary by trying to find memory addresses using hex-signatures. 
It will generate a file called "analysis.json", which will include all adresses, which goes something like this:
```json
   {
    "FREE_FLASH_MEMORY": "0x5a7700",
    "FREE_RAM_MEMORY": "0x80d000",
    "TABLE_X": "0x10000",
    ...
}
   ```
This file includes all variables needed for a successful compilation afterwards

### Step 2: Compilation

It will prepare and compile the selected patches to a binary blob. This is done using the normal GCC compilation process
The C-Code should be written in a special way to make sure it will be included in the final binary. Here are the "code-standards":

#### ECU-Variable usage:

```cpp
   #include "autogenerated.h"   
```
This header includes all variables from Step1. Its useful to have it, but not a must. You then can use it to read memory variables of the ECU:
```cpp
   int *tableX = TABLE_X;
```

#### Own Variable/Function usage:
You should always prepend "attribute-section" for your function, to ensure it will go into .code section. If you avoid writing it, it wont be compiled.
```cpp
   void myfunction(void) __attribute__((section(".code"))) ;
   void myfunction (void)
   {
   }
```
All your constant variables, should also go to "values" section. The values section is in flash memory
```cpp
   const int myvariable __attribute__((section(".values"))) = 0x100 ;
```
All your Runtime variables should go to "variables". The variables section is in ram.
```cpp
   int myvariable __attribute__((section(".variables")));
```

#### How does the compiler work:
It will compile everything together into a ELF called "code.elf". Then it will extract only the section called ".flash" into "flash.bin", which is placed to the
address of "FREE_FLASH_MEMORY" variable.
Then it will extract a memory map of the compiled code and place it into "memorymap.json"

### Step 3: Patcher

The patcher will use the analysis.json and memorymap.json from the previous steps and add it to the target binary. It includes a mini-powerpc compiler to be able 
to compile "jump" instructions to point to your code.




## Can it be adjusted to MED1X,SIMOS XX,EDC XX ?

Probably. Its not that hard, as you dont have to rewrite most of the structure.
You will have to: 
1. Find your own signatures of the binaries.
2. Find a suitable c-compiler
3. Rewrite the patcher-mini-compiler
4. Rewrite patches to match your requirements


